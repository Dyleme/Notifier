// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: timetable.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTimetableTask = `-- name: AddTimetableTask :one
INSERT INTO timetable_tasks (
            user_id,
            task_id,
            text,
            start,
            finish,
            description,
            done
) VALUES (
            $1,
            $2,
            $3,
            $4,
            $5,
            $6,
            $7
)
RETURNING id, created_at, text, description, user_id, start, finish, done, task_id
`

type AddTimetableTaskParams struct {
	UserID      int32
	TaskID      int32
	Text        string
	Start       pgtype.Timestamp
	Finish      pgtype.Timestamp
	Description pgtype.Text
	Done        bool
}

func (q *Queries) AddTimetableTask(ctx context.Context, arg AddTimetableTaskParams) (TimetableTask, error) {
	row := q.db.QueryRow(ctx, addTimetableTask,
		arg.UserID,
		arg.TaskID,
		arg.Text,
		arg.Start,
		arg.Finish,
		arg.Description,
		arg.Done,
	)
	var i TimetableTask
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Text,
		&i.Description,
		&i.UserID,
		&i.Start,
		&i.Finish,
		&i.Done,
		&i.TaskID,
	)
	return i, err
}

const deleteTimetableTask = `-- name: DeleteTimetableTask :one
DELETE
FROM timetable_tasks
WHERE id = $1
  AND user_id = $2
RETURNING count(*) as deleted_amount
`

type DeleteTimetableTaskParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) DeleteTimetableTask(ctx context.Context, arg DeleteTimetableTaskParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteTimetableTask, arg.ID, arg.UserID)
	var deleted_amount int64
	err := row.Scan(&deleted_amount)
	return deleted_amount, err
}

const getTimetableTask = `-- name: GetTimetableTask :one
SELECT id, created_at, text, description, user_id, start, finish, done, task_id
FROM timetable_tasks
WHERE id = $1
  AND user_id = $2
`

type GetTimetableTaskParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) GetTimetableTask(ctx context.Context, arg GetTimetableTaskParams) (TimetableTask, error) {
	row := q.db.QueryRow(ctx, getTimetableTask, arg.ID, arg.UserID)
	var i TimetableTask
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Text,
		&i.Description,
		&i.UserID,
		&i.Start,
		&i.Finish,
		&i.Done,
		&i.TaskID,
	)
	return i, err
}

const getTimetableTasksInPeriod = `-- name: GetTimetableTasksInPeriod :many
SELECT id, created_at, text, description, user_id, start, finish, done, task_id
FROM timetable_tasks
WHERE user_id = $1
  AND start BETWEEN $2 AND $3
`

type GetTimetableTasksInPeriodParams struct {
	UserID   int32
	FromTime pgtype.Timestamp
	ToTime   pgtype.Timestamp
}

func (q *Queries) GetTimetableTasksInPeriod(ctx context.Context, arg GetTimetableTasksInPeriodParams) ([]TimetableTask, error) {
	rows, err := q.db.Query(ctx, getTimetableTasksInPeriod, arg.UserID, arg.FromTime, arg.ToTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TimetableTask
	for rows.Next() {
		var i TimetableTask
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Text,
			&i.Description,
			&i.UserID,
			&i.Start,
			&i.Finish,
			&i.Done,
			&i.TaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimetableTasks = `-- name: ListTimetableTasks :many
SELECT id, created_at, text, description, user_id, start, finish, done, task_id
FROM timetable_tasks
WHERE user_id = $1
`

func (q *Queries) ListTimetableTasks(ctx context.Context, userID int32) ([]TimetableTask, error) {
	rows, err := q.db.Query(ctx, listTimetableTasks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TimetableTask
	for rows.Next() {
		var i TimetableTask
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Text,
			&i.Description,
			&i.UserID,
			&i.Start,
			&i.Finish,
			&i.Done,
			&i.TaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTimetableTask = `-- name: UpdateTimetableTask :one
UPDATE timetable_tasks
   SET start = $1,
       finish = $2,
       text = $3,
       description = $4,
       done = $5
 WHERE id = $6
   AND user_id = $7
RETURNING id, created_at, text, description, user_id, start, finish, done, task_id
`

type UpdateTimetableTaskParams struct {
	Start       pgtype.Timestamp
	Finish      pgtype.Timestamp
	Text        string
	Description pgtype.Text
	Done        bool
	ID          int32
	UserID      int32
}

func (q *Queries) UpdateTimetableTask(ctx context.Context, arg UpdateTimetableTaskParams) (TimetableTask, error) {
	row := q.db.QueryRow(ctx, updateTimetableTask,
		arg.Start,
		arg.Finish,
		arg.Text,
		arg.Description,
		arg.Done,
		arg.ID,
		arg.UserID,
	)
	var i TimetableTask
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Text,
		&i.Description,
		&i.UserID,
		&i.Start,
		&i.Finish,
		&i.Done,
		&i.TaskID,
	)
	return i, err
}
