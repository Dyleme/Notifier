// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: events.sql

package queries

import (
	"context"

	domains "github.com/Dyleme/Notifier/internal/timetable-service/domains"
	"github.com/jackc/pgx/v5/pgtype"
)

const addEvent = `-- name: AddEvent :one
INSERT INTO events (user_id,
                             text,
                             start,
                             description,
                             done,
                             notification)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6)
RETURNING id, created_at, text, description, user_id, start, done, notification
`

type AddEventParams struct {
	UserID       int32
	Text         string
	Start        pgtype.Timestamp
	Description  pgtype.Text
	Done         bool
	Notification domains.Notification
}

func (q *Queries) AddEvent(ctx context.Context, arg AddEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, addEvent,
		arg.UserID,
		arg.Text,
		arg.Start,
		arg.Description,
		arg.Done,
		arg.Notification,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Text,
		&i.Description,
		&i.UserID,
		&i.Start,
		&i.Done,
		&i.Notification,
	)
	return i, err
}

const countGetEventsInPeriod = `-- name: CountGetEventsInPeriod :one
SELECT count(*)
FROM events
WHERE user_id = $1
  AND start BETWEEN $2 AND $3
`

type CountGetEventsInPeriodParams struct {
	UserID   int32
	FromTime pgtype.Timestamp
	ToTime   pgtype.Timestamp
}

func (q *Queries) CountGetEventsInPeriod(ctx context.Context, arg CountGetEventsInPeriodParams) (int64, error) {
	row := q.db.QueryRow(ctx, countGetEventsInPeriod, arg.UserID, arg.FromTime, arg.ToTime)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countListEvents = `-- name: CountListEvents :one
SELECT count(*)
FROM events
WHERE user_id = $1
`

func (q *Queries) CountListEvents(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countListEvents, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const delayEvent = `-- name: DelayEvent :exec
UPDATE events AS t
SET notification = JSONB_SET(notificaiton, '{"delayed_till"}',$1::TIMESTAMP)
WHERE id = $2
  AND user_id = $3
`

type DelayEventParams struct {
	Till   pgtype.Timestamp
	ID     int32
	UserID int32
}

func (q *Queries) DelayEvent(ctx context.Context, arg DelayEventParams) error {
	_, err := q.db.Exec(ctx, delayEvent, arg.Till, arg.ID, arg.UserID)
	return err
}

const deleteEvent = `-- name: DeleteEvent :one
DELETE
FROM events
WHERE id = $1
  AND user_id = $2
RETURNING COUNT(*) AS deleted_amount
`

type DeleteEventParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) DeleteEvent(ctx context.Context, arg DeleteEventParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteEvent, arg.ID, arg.UserID)
	var deleted_amount int64
	err := row.Scan(&deleted_amount)
	return deleted_amount, err
}

const getEvent = `-- name: GetEvent :one
SELECT id, created_at, text, description, user_id, start, done, notification
FROM events
WHERE id = $1
  AND user_id = $2
`

type GetEventParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) GetEvent(ctx context.Context, arg GetEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, arg.ID, arg.UserID)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Text,
		&i.Description,
		&i.UserID,
		&i.Start,
		&i.Done,
		&i.Notification,
	)
	return i, err
}

const getEventReadyTasks = `-- name: GetEventReadyTasks :many
SELECT id, created_at, text, description, user_id, start, done, notification
FROM events AS t
WHERE t.start <= NOW()
  AND t.done = FALSE
  AND t.notification ->> 'sended' = 'false'
  AND (
        t.notification ->> 'delayed_till' IS NULL
        OR CAST(t.notification ->> 'delayed_till' AS TIMESTAMP) <= NOW()
    )
`

func (q *Queries) GetEventReadyTasks(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventReadyTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Text,
			&i.Description,
			&i.UserID,
			&i.Start,
			&i.Done,
			&i.Notification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsInPeriod = `-- name: GetEventsInPeriod :many
SELECT id, created_at, text, description, user_id, start, done, notification
FROM events
WHERE user_id = $1
  AND start BETWEEN $2 AND $3
ORDER BY id DESC
LIMIT $5
OFFSET $4
`

type GetEventsInPeriodParams struct {
	UserID   int32
	FromTime pgtype.Timestamp
	ToTime   pgtype.Timestamp
	Off      int32
	Lim      int32
}

func (q *Queries) GetEventsInPeriod(ctx context.Context, arg GetEventsInPeriodParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsInPeriod,
		arg.UserID,
		arg.FromTime,
		arg.ToTime,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Text,
			&i.Description,
			&i.UserID,
			&i.Start,
			&i.Done,
			&i.Notification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvents = `-- name: ListEvents :many
SELECT id, created_at, text, description, user_id, start, done, notification
FROM events
WHERE user_id = $1
ORDER BY id DESC
LIMIT $3
OFFSET $2
`

type ListEventsParams struct {
	UserID int32
	Off    int32
	Lim    int32
}

func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEvents, arg.UserID, arg.Off, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Text,
			&i.Description,
			&i.UserID,
			&i.Start,
			&i.Done,
			&i.Notification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationSended = `-- name: MarkNotificationSended :exec
UPDATE events AS t
SET notification = notification || '{"sended":true}'
WHERE id = ANY ($1::INTEGER[])
`

func (q *Queries) MarkNotificationSended(ctx context.Context, ids []int32) error {
	_, err := q.db.Exec(ctx, markNotificationSended, ids)
	return err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET start       = $1,
    text        = $2,
    description = $3,
    done        = $4
WHERE id = $5
  AND user_id = $6
RETURNING id, created_at, text, description, user_id, start, done, notification
`

type UpdateEventParams struct {
	Start       pgtype.Timestamp
	Text        string
	Description pgtype.Text
	Done        bool
	ID          int32
	UserID      int32
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.Start,
		arg.Text,
		arg.Description,
		arg.Done,
		arg.ID,
		arg.UserID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Text,
		&i.Description,
		&i.UserID,
		&i.Start,
		&i.Done,
		&i.Notification,
	)
	return i, err
}

const updateNotificationParams = `-- name: UpdateNotificationParams :one
UPDATE events AS t
SET notification = JSONB_SET(notification, '{notification_params}', $1)
WHERE id = $2
  AND user_id = $3
RETURNING notification
`

type UpdateNotificationParamsParams struct {
	Params []byte
	ID     int32
	UserID int32
}

func (q *Queries) UpdateNotificationParams(ctx context.Context, arg UpdateNotificationParamsParams) (domains.Notification, error) {
	row := q.db.QueryRow(ctx, updateNotificationParams, arg.Params, arg.ID, arg.UserID)
	var notification domains.Notification
	err := row.Scan(&notification)
	return notification, err
}
